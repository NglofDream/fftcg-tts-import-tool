<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON Processing</title>
</head>
<body>
    <label for="deckId">Enter Deck ID / Website link:</label>
    <input type="text" id="deckId">
    <button id="fetchButton">Download Deck</button>

    <h2>Deck Data:</h2>
    <pre id="deck-data">Please enter a Deck ID and click "Download Deck".</pre>

    <script>
        async function fetchJSON(url) {
            const response = await fetch(url);
            return response.json();
        }

        function saveJSON(data, filename) {
            const blob = new Blob([JSON.stringify(data, null, 4)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        async function processData(deckData) {
            try {
                const githubBaseUrl = 'https://raw.githubusercontent.com/nglofdream/test/main/';
                const templateFileUrl = `${githubBaseUrl}template.json`;
                const ttsdeckFileUrl = `${githubBaseUrl}ttsdeck.json`;

                // Access the "card" object inside each "cards" array item
                const dataList = [];
                deckData.cards.forEach(item => {
                    for (let i = 0; i < item.quantity; i++) {
                        dataList.push(item.card);
                    }
                });

                const templateData = await fetchJSON(templateFileUrl);
                const ttsdeckData = await fetchJSON(ttsdeckFileUrl);

                let newDataList = [];

                dataList.forEach(item => {
                    const [serialNumber1, serialNumber2] = item.serial_number.split('-');
                    const formattedSerialNumber1 = /^\d$/.test(serialNumber1) ? `0${serialNumber1}` : serialNumber1;
                    const rarity = item.rarity === "Promo" ? "" : item.rarity.charAt(0);

                    newDataList.push({
                        Nickname: item.name,
                        FaceURL: item.image,
                        Description: item.abilities ? item.abilities.join(', ') : ""
                    });
                });

                let deck = [];
                let deckIds = [];
                let tempData = [];
                let ids = 554;

                newDataList.forEach((item, i) => {
                    let temporaryDeckCode = {
                        FaceURL: item.FaceURL,
                        BackURL: "http://cloud-3.steamusercontent.com/ugc/948455238665576576/85063172B8C340602E8D6C783A457122F53F7843/",
                        NumWidth: 1,
                        NumHeight: 1,
                        BackIsHidden: "true",
                        UniqueBack: "false",
                        Type: 0
                    };

                    tempData.push(temporaryDeckCode);

                    let temporaryCardCode = {
                        Name: "CardCustom",
                        Transform: {
                            posX: 42.494194,
                            posY: 0.989706635,
                            posZ: 10.5498743,
                            rotX: 359.7435,
                            rotY: 179.999451,
                            rotZ: -0.00222716271,
                            scaleX: 2.17791772,
                            scaleY: 1.0,
                            scaleZ: 2.17791772
                        },
                        Nickname: item.Nickname,
                        Description: item.Description,
                        CardID: (ids + i) * 100,
                        CustomDeck: {
                            [ids + i]: {
                                FaceURL: item.FaceURL,
                                BackURL: "http://cloud-3.steamusercontent.com/ugc/948455238665576576/85063172B8C340602E8D6C783A457122F53F7843/",
                                NumWidth: 1,
                                NumHeight: 1,
                                BackIsHidden: "true",
                                UniqueBack: "false",
                                Type: 0
                            }
                        }
                    };

                    deckIds.push((ids + i) * 100);
                    deck.push(temporaryCardCode);
                });

                tempData.forEach((item, index) => {
                    ttsdeckData.ObjectStates[0].CustomDeck[ids + index] = item;
                });

                ttsdeckData.ObjectStates[0].DeckIDs = deckIds;
                ttsdeckData.ObjectStates[0].ContainedObjects = deck;

                saveJSON(ttsdeckData, 'deck.json');
            } catch (error) {
                console.error('Error processing data:', error);
            }
        }

        document.getElementById('fetchButton').addEventListener('click', () => {
            const deckId = document.getElementById('deckId').value;
            const url = `https://ffdecks.com/api/deck?deck_id=${deckId}`;

            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    const cardsData = { cards: data.cards.map(item => item.card) };

                    processData(data);
                })
                .catch(error => {
                    console.error('There was a problem with the fetch operation:', error);
                    const pre = document.getElementById('deck-data');
                    pre.textContent = 'Failed to load data. Please check the Deck ID.';
                });
        });
    </script>
</body>
</html>
